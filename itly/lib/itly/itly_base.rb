# 
# lib/itly/itly_base.rb
# 
# This file is auto-generated by Iteratively.
# To update run 'itly pull analytics_service'
# 
# Questions? We're here to help:
# https://www.iterative.ly/docs/interacting-with-the-sdk/#ruby
# 

require 'json'
require 'logger'
require 'ostruct'

begin
  require 'json_schemer'
rescue LoadError
  raise "You don't have #{name} installed in your application. Please add it to your Gemfile and run bundle install."
end

module Itly
  class Error < StandardError; end
  class InitializationError < Error; end
  class ValidationError < Error; end

  DestinationOptions = Struct.new(:amplitude, :mixpanel, :segment, :custom)

  class Properties
    attr_reader :properties

    def initialize(properties)
      @properties = properties
    end
  end

  class Event < Properties
    attr_reader :name, :schema

    def initialize(name, schema, properties = {})
      super(properties)
      @name = name
      @schema = schema
    end
  end

  class Options
    attr_accessor :environment, :disabled, :logger, :context
    attr_reader :destinations

    def initialize
      @environment         = :development
      @disabled            = false
      @destinations = DestinationOptions.new({}, {}, {}, nil)
      @context             = nil
      @logger              = Logger.new(STDOUT, level: Logger::Severity::ERROR)
      @logger.progname     = 'Itly'
    end

    %i[production development].each { |e| define_method(:"#{e}?") { environment == e } }
  end

  module Initializable
    def self.included(base)
      base.extend ClassMethods
    end

    module ClassMethods
      def set_properties(properties)
        @properties = properties
      end

      def set_validators(schemas)
        @validators = JSON.parse(schemas)
      end

      def register_adapter(vendor, adapter)
        @adapters << adapter
        destinations[vendor] = adapter
      end
    end
  end

  include Initializable

  module Adapters
    class Base
      attr_reader :client, :options, :key

      def initialize(key, options = {})
        @key, @options = key, options
      end

      def init
        raise NotImplementedError
      end

      def alias(user_id, previous_id); end
      def identify(user_id, properties = {}); end
      def group(user_id, group_id, properties = {}); end
      def track(user_id, event_name, properties={}); end
      def reset; end
    end

    ##
    # CustomBase
    #
    # Base class for Custom destination adapters
    #
    # e.g. class MyCustomDestinationAdapter < Itly::Adapters::CustomBase
    class CustomBase
      def initialize(options = {})
        key = 'custom'
        @key, @options = key, options
      end
    end
  end

  class << self
    attr_reader :is_initialized
    attr_reader :options
    attr_reader :properties
    attr_reader :validators
    attr_reader :destinations

    def load
      raise InitializationError.new('Itly is already initialized.') if is_initialized

      @destinations = OpenStruct.new
      @adapters = []

      @options = Options.new
      yield options if block_given?

      on_initialize

      @adapters.each(&:init)

      @is_initialized = true
    end

    def make_compact_hash
      {}.tap { |h| yield h; h.select! { |_, v| !v.nil? } }
    end

    def is_initialized_and_enabled
      raise InitializationError.new('Itly is not initialized.') unless is_initialized
      return if self.options.disabled

      yield
    end

    def validate_schema(event)
      errors = JSONSchemer.schema(
          validators[event.schema]
      ).validate(
          JSON[event.properties.to_json]
      ).to_a
      return if errors.empty?

      errors = errors.map { |e|
        type = (e['type'] == e['schema']['type']) ? 'type' : e['type']
        value = (type == 'type') ? e['type'] : e['schema'][e['type']]
        [
            "Error validating '#{e['data_pointer']}' on '#{event.name}'." +
                " Value: '#{e['data']}' failed '#{type}' '#{value}'",
            e
        ]
      }
      errors = JSON.generate(errors)

      options.logger.error(errors)
      raise ValidationError.new(errors) unless options.production?
    end

    def reset
      is_initialized_and_enabled do
        @adapters.each(&:reset)
      end
    end

    def track(user_id, event)
      is_initialized_and_enabled do
        validate_schema(event)

        properties = make_compact_hash do |h|
          h['itlySchema']  = event.schema
          h.merge!(self.properties)
          h.merge!(options.context.properties) unless options.context.nil?
          h.merge!(event.properties)
        end

        options.logger.debug("Tracking Event: '#{event.name}' Properties: #{properties}")
        @adapters.each { |adapter| adapter.track(user_id, event.name, properties) }
      end
    end

    def on_initialize
      raise NotImplementedError
    end
  end
end
